import { defineComponent as Ae, h as ne } from "vue";
const E = /^[a-z0-9]+(-[a-z0-9]+)*$/, M = (e, t, n, r = "") => {
  const o = e.split(":");
  if (e.slice(0, 1) === "@") {
    if (o.length < 2 || o.length > 3)
      return null;
    r = o.shift().slice(1);
  }
  if (o.length > 3 || !o.length)
    return null;
  if (o.length > 1) {
    const c = o.pop(), l = o.pop(), f = {
      // Allow provider without '@': "provider:prefix:name"
      provider: o.length > 0 ? o[0] : r,
      prefix: l,
      name: c
    };
    return t && !_(f) ? null : f;
  }
  const i = o[0], s = i.split("-");
  if (s.length > 1) {
    const c = {
      provider: r,
      prefix: s.shift(),
      name: s.join("-")
    };
    return t && !_(c) ? null : c;
  }
  if (n && r === "") {
    const c = {
      provider: r,
      prefix: "",
      name: i
    };
    return t && !_(c, n) ? null : c;
  }
  return null;
}, _ = (e, t) => e ? !!((e.provider === "" || e.provider.match(E)) && (t && e.prefix === "" || e.prefix.match(E)) && e.name.match(E)) : !1, ye = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), R = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), T = Object.freeze({
  ...ye,
  ...R
}), $ = Object.freeze({
  ...T,
  body: "",
  hidden: !1
});
function _e(e, t) {
  const n = {};
  !e.hFlip != !t.hFlip && (n.hFlip = !0), !e.vFlip != !t.vFlip && (n.vFlip = !0);
  const r = ((e.rotate || 0) + (t.rotate || 0)) % 4;
  return r && (n.rotate = r), n;
}
function oe(e, t) {
  const n = _e(e, t);
  for (const r in $)
    r in R ? r in e && !(r in n) && (n[r] = R[r]) : r in t ? n[r] = t[r] : r in e && (n[r] = e[r]);
  return n;
}
function De(e, t) {
  const n = e.icons, r = e.aliases || /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  function i(s) {
    if (n[s])
      return o[s] = [];
    if (!(s in o)) {
      o[s] = null;
      const c = r[s] && r[s].parent, l = c && i(c);
      l && (o[s] = [c].concat(l));
    }
    return o[s];
  }
  return Object.keys(n).concat(Object.keys(r)).forEach(i), o;
}
function Ne(e, t, n) {
  const r = e.icons, o = e.aliases || /* @__PURE__ */ Object.create(null);
  let i = {};
  function s(c) {
    i = oe(
      r[c] || o[c],
      i
    );
  }
  return s(t), n.forEach(s), oe(e, i);
}
function be(e, t) {
  const n = [];
  if (typeof e != "object" || typeof e.icons != "object")
    return n;
  e.not_found instanceof Array && e.not_found.forEach((o) => {
    t(o, null), n.push(o);
  });
  const r = De(e);
  for (const o in r) {
    const i = r[o];
    i && (t(o, Ne(e, o, i)), n.push(o));
  }
  return n;
}
const Re = {
  provider: "",
  aliases: {},
  not_found: {},
  ...ye
};
function V(e, t) {
  for (const n in t)
    if (n in e && typeof e[n] != typeof t[n])
      return !1;
  return !0;
}
function we(e) {
  if (typeof e != "object" || e === null)
    return null;
  const t = e;
  if (typeof t.prefix != "string" || !e.icons || typeof e.icons != "object" || !V(e, Re))
    return null;
  const n = t.icons;
  for (const o in n) {
    const i = n[o];
    if (!o.match(E) || typeof i.body != "string" || !V(
      i,
      $
    ))
      return null;
  }
  const r = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const o in r) {
    const i = r[o], s = i.parent;
    if (!o.match(E) || typeof s != "string" || !n[s] && !r[s] || !V(
      i,
      $
    ))
      return null;
  }
  return t;
}
const re = /* @__PURE__ */ Object.create(null);
function Be(e, t) {
  return {
    provider: e,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function C(e, t) {
  const n = re[e] || (re[e] = /* @__PURE__ */ Object.create(null));
  return n[t] || (n[t] = Be(e, t));
}
function W(e, t) {
  return we(t) ? be(t, (n, r) => {
    r ? e.icons[n] = r : e.missing.add(n);
  }) : [];
}
function ze(e, t, n) {
  try {
    if (typeof n.body == "string")
      return e.icons[t] = { ...n }, !0;
  } catch {
  }
  return !1;
}
let O = !1;
function xe(e) {
  return typeof e == "boolean" && (O = e), O;
}
function B(e) {
  const t = typeof e == "string" ? M(e, !0, O) : e;
  if (t) {
    const n = C(t.provider, t.prefix), r = t.name;
    return n.icons[r] || (n.missing.has(r) ? null : void 0);
  }
}
function Ve(e, t) {
  const n = M(e, !0, O);
  if (!n)
    return !1;
  const r = C(n.provider, n.prefix);
  return ze(r, n.name, t);
}
function Qe(e, t) {
  if (typeof e != "object")
    return !1;
  if (typeof t != "string" && (t = e.provider || ""), O && !t && !e.prefix) {
    let o = !1;
    return we(e) && (e.prefix = "", be(e, (i, s) => {
      s && Ve(i, s) && (o = !0);
    })), o;
  }
  const n = e.prefix;
  if (!_({
    provider: t,
    prefix: n,
    name: "a"
  }))
    return !1;
  const r = C(t, n);
  return !!W(r, e);
}
function Nt(e) {
  return !!B(e);
}
function Rt(e) {
  const t = B(e);
  return t ? {
    ...T,
    ...t
  } : null;
}
const Ie = Object.freeze({
  width: null,
  height: null
}), Se = Object.freeze({
  // Dimensions
  ...Ie,
  // Transformations
  ...R
}), $e = /(-?[0-9.]*[0-9]+[0-9.]*)/g, qe = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function ie(e, t, n) {
  if (t === 1)
    return e;
  if (n = n || 100, typeof e == "number")
    return Math.ceil(e * t * n) / n;
  if (typeof e != "string")
    return e;
  const r = e.split($e);
  if (r === null || !r.length)
    return e;
  const o = [];
  let i = r.shift(), s = qe.test(i);
  for (; ; ) {
    if (s) {
      const c = parseFloat(i);
      isNaN(c) ? o.push(i) : o.push(Math.ceil(c * t * n) / n);
    } else
      o.push(i);
    if (i = r.shift(), i === void 0)
      return o.join("");
    s = !s;
  }
}
function He(e, t = "defs") {
  let n = "";
  const r = e.indexOf("<" + t);
  for (; r >= 0; ) {
    const o = e.indexOf(">", r), i = e.indexOf("</" + t);
    if (o === -1 || i === -1)
      break;
    const s = e.indexOf(">", i);
    if (s === -1)
      break;
    n += e.slice(o + 1, i).trim(), e = e.slice(0, r).trim() + e.slice(s + 1);
  }
  return {
    defs: n,
    content: e
  };
}
function Ue(e, t) {
  return e ? "<defs>" + e + "</defs>" + t : t;
}
function Ge(e, t, n) {
  const r = He(e);
  return Ue(r.defs, t + r.content + n);
}
const Ke = (e) => e === "unset" || e === "undefined" || e === "none";
function Je(e, t) {
  const n = {
    ...T,
    ...e
  }, r = {
    ...Se,
    ...t
  }, o = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let i = n.body;
  [n, r].forEach((g) => {
    const a = [], k = g.hFlip, I = g.vFlip;
    let w = g.rotate;
    k ? I ? w += 2 : (a.push(
      "translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"
    ), a.push("scale(-1 1)"), o.top = o.left = 0) : I && (a.push(
      "translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"
    ), a.push("scale(1 -1)"), o.top = o.left = 0);
    let y;
    switch (w < 0 && (w -= Math.floor(w / 4) * 4), w = w % 4, w) {
      case 1:
        y = o.height / 2 + o.top, a.unshift(
          "rotate(90 " + y.toString() + " " + y.toString() + ")"
        );
        break;
      case 2:
        a.unshift(
          "rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"
        );
        break;
      case 3:
        y = o.width / 2 + o.left, a.unshift(
          "rotate(-90 " + y.toString() + " " + y.toString() + ")"
        );
        break;
    }
    w % 2 === 1 && (o.left !== o.top && (y = o.left, o.left = o.top, o.top = y), o.width !== o.height && (y = o.width, o.width = o.height, o.height = y)), a.length && (i = Ge(
      i,
      '<g transform="' + a.join(" ") + '">',
      "</g>"
    ));
  });
  const s = r.width, c = r.height, l = o.width, f = o.height;
  let u, d;
  s === null ? (d = c === null ? "1em" : c === "auto" ? f : c, u = ie(d, l / f)) : (u = s === "auto" ? l : s, d = c === null ? ie(u, f / l) : c === "auto" ? f : c);
  const p = {}, m = (g, a) => {
    Ke(a) || (p[g] = a.toString());
  };
  m("width", u), m("height", d);
  const x = [o.left, o.top, l, f];
  return p.viewBox = x.join(" "), {
    attributes: p,
    viewBox: x,
    body: i
  };
}
const We = /\sid="(\S+)"/g, Xe = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let Ye = 0;
function Ze(e, t = Xe) {
  const n = [];
  let r;
  for (; r = We.exec(e); )
    n.push(r[1]);
  if (!n.length)
    return e;
  const o = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((i) => {
    const s = typeof t == "function" ? t(i) : t + (Ye++).toString(), c = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    e = e.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + c + ')([")]|\\.[a-z])', "g"),
      "$1" + s + o + "$3"
    );
  }), e = e.replace(new RegExp(o, "g"), ""), e;
}
const q = /* @__PURE__ */ Object.create(null);
function et(e, t) {
  q[e] = t;
}
function H(e) {
  return q[e] || q[""];
}
function X(e) {
  let t;
  if (typeof e.resources == "string")
    t = [e.resources];
  else if (t = e.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: e.path || "/",
    // URL length limit
    maxURL: e.maxURL || 500,
    // Timeout before next host is used.
    rotate: e.rotate || 750,
    // Timeout before failing query.
    timeout: e.timeout || 5e3,
    // Randomise default API end point.
    random: e.random === !0,
    // Start index
    index: e.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: e.dataAfterTimeout !== !1
  };
}
const Y = /* @__PURE__ */ Object.create(null), P = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], D = [];
for (; P.length > 0; )
  P.length === 1 || Math.random() > 0.5 ? D.push(P.shift()) : D.push(P.pop());
Y[""] = X({
  resources: ["https://api.iconify.design"].concat(D)
});
function tt(e, t) {
  const n = X(t);
  return n === null ? !1 : (Y[e] = n, !0);
}
function Z(e) {
  return Y[e];
}
const nt = () => {
  let e;
  try {
    if (e = fetch, typeof e == "function")
      return e;
  } catch {
  }
};
let se = nt();
function ot(e, t) {
  const n = Z(e);
  if (!n)
    return 0;
  let r;
  if (!n.maxURL)
    r = 0;
  else {
    let o = 0;
    n.resources.forEach((s) => {
      o = Math.max(o, s.length);
    });
    const i = t + ".json?icons=";
    r = n.maxURL - o - n.path.length - i.length;
  }
  return r;
}
function rt(e) {
  return e === 404;
}
const it = (e, t, n) => {
  const r = [], o = ot(e, t), i = "icons";
  let s = {
    type: i,
    provider: e,
    prefix: t,
    icons: []
  }, c = 0;
  return n.forEach((l, f) => {
    c += l.length + 1, c >= o && f > 0 && (r.push(s), s = {
      type: i,
      provider: e,
      prefix: t,
      icons: []
    }, c = l.length), s.icons.push(l);
  }), r.push(s), r;
};
function st(e) {
  if (typeof e == "string") {
    const t = Z(e);
    if (t)
      return t.path;
  }
  return "/";
}
const ct = (e, t, n) => {
  if (!se) {
    n("abort", 424);
    return;
  }
  let r = st(t.provider);
  switch (t.type) {
    case "icons": {
      const i = t.prefix, c = t.icons.join(","), l = new URLSearchParams({
        icons: c
      });
      r += i + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const i = t.uri;
      r += i.slice(0, 1) === "/" ? i.slice(1) : i;
      break;
    }
    default:
      n("abort", 400);
      return;
  }
  let o = 503;
  se(e + r).then((i) => {
    const s = i.status;
    if (s !== 200) {
      setTimeout(() => {
        n(rt(s) ? "abort" : "next", s);
      });
      return;
    }
    return o = 501, i.json();
  }).then((i) => {
    if (typeof i != "object" || i === null) {
      setTimeout(() => {
        i === 404 ? n("abort", i) : n("next", o);
      });
      return;
    }
    setTimeout(() => {
      n("success", i);
    });
  }).catch(() => {
    n("next", o);
  });
}, lt = {
  prepare: it,
  send: ct
};
function ft(e) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, n = /* @__PURE__ */ Object.create(null);
  e.sort((o, i) => o.provider !== i.provider ? o.provider.localeCompare(i.provider) : o.prefix !== i.prefix ? o.prefix.localeCompare(i.prefix) : o.name.localeCompare(i.name));
  let r = {
    provider: "",
    prefix: "",
    name: ""
  };
  return e.forEach((o) => {
    if (r.name === o.name && r.prefix === o.prefix && r.provider === o.provider)
      return;
    r = o;
    const i = o.provider, s = o.prefix, c = o.name, l = n[i] || (n[i] = /* @__PURE__ */ Object.create(null)), f = l[s] || (l[s] = C(i, s));
    let u;
    c in f.icons ? u = t.loaded : s === "" || f.missing.has(c) ? u = t.missing : u = t.pending;
    const d = {
      provider: i,
      prefix: s,
      name: c
    };
    u.push(d);
  }), t;
}
function ve(e, t) {
  e.forEach((n) => {
    const r = n.loaderCallbacks;
    r && (n.loaderCallbacks = r.filter((o) => o.id !== t));
  });
}
function ut(e) {
  e.pendingCallbacksFlag || (e.pendingCallbacksFlag = !0, setTimeout(() => {
    e.pendingCallbacksFlag = !1;
    const t = e.loaderCallbacks ? e.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let n = !1;
    const r = e.provider, o = e.prefix;
    t.forEach((i) => {
      const s = i.icons, c = s.pending.length;
      s.pending = s.pending.filter((l) => {
        if (l.prefix !== o)
          return !0;
        const f = l.name;
        if (e.icons[f])
          s.loaded.push({
            provider: r,
            prefix: o,
            name: f
          });
        else if (e.missing.has(f))
          s.missing.push({
            provider: r,
            prefix: o,
            name: f
          });
        else
          return n = !0, !0;
        return !1;
      }), s.pending.length !== c && (n || ve([e], i.id), i.callback(
        s.loaded.slice(0),
        s.missing.slice(0),
        s.pending.slice(0),
        i.abort
      ));
    });
  }));
}
let at = 0;
function dt(e, t, n) {
  const r = at++, o = ve.bind(null, n, r);
  if (!t.pending.length)
    return o;
  const i = {
    id: r,
    icons: t,
    callback: e,
    abort: o
  };
  return n.forEach((s) => {
    (s.loaderCallbacks || (s.loaderCallbacks = [])).push(i);
  }), o;
}
function ht(e, t = !0, n = !1) {
  const r = [];
  return e.forEach((o) => {
    const i = typeof o == "string" ? M(o, t, n) : o;
    i && r.push(i);
  }), r;
}
var pt = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function gt(e, t, n, r) {
  const o = e.resources.length, i = e.random ? Math.floor(Math.random() * o) : e.index;
  let s;
  if (e.random) {
    let h = e.resources.slice(0);
    for (s = []; h.length > 1; ) {
      const b = Math.floor(Math.random() * h.length);
      s.push(h[b]), h = h.slice(0, b).concat(h.slice(b + 1));
    }
    s = s.concat(h);
  } else
    s = e.resources.slice(i).concat(e.resources.slice(0, i));
  const c = Date.now();
  let l = "pending", f = 0, u, d = null, p = [], m = [];
  typeof r == "function" && m.push(r);
  function x() {
    d && (clearTimeout(d), d = null);
  }
  function g() {
    l === "pending" && (l = "aborted"), x(), p.forEach((h) => {
      h.status === "pending" && (h.status = "aborted");
    }), p = [];
  }
  function a(h, b) {
    b && (m = []), typeof h == "function" && m.push(h);
  }
  function k() {
    return {
      startTime: c,
      payload: t,
      status: l,
      queriesSent: f,
      queriesPending: p.length,
      subscribe: a,
      abort: g
    };
  }
  function I() {
    l = "failed", m.forEach((h) => {
      h(void 0, u);
    });
  }
  function w() {
    p.forEach((h) => {
      h.status === "pending" && (h.status = "aborted");
    }), p = [];
  }
  function y(h, b, j) {
    const F = b !== "success";
    switch (p = p.filter((S) => S !== h), l) {
      case "pending":
        break;
      case "failed":
        if (F || !e.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (b === "abort") {
      u = j, I();
      return;
    }
    if (F) {
      u = j, p.length || (s.length ? z() : I());
      return;
    }
    if (x(), w(), !e.random) {
      const S = e.resources.indexOf(h.resource);
      S !== -1 && S !== e.index && (e.index = S);
    }
    l = "completed", m.forEach((S) => {
      S(j);
    });
  }
  function z() {
    if (l !== "pending")
      return;
    x();
    const h = s.shift();
    if (h === void 0) {
      if (p.length) {
        d = setTimeout(() => {
          x(), l === "pending" && (w(), I());
        }, e.timeout);
        return;
      }
      I();
      return;
    }
    const b = {
      status: "pending",
      resource: h,
      callback: (j, F) => {
        y(b, j, F);
      }
    };
    p.push(b), f++, d = setTimeout(z, e.rotate), n(h, t, b.callback);
  }
  return setTimeout(z), k;
}
function Ce(e) {
  const t = {
    ...pt,
    ...e
  };
  let n = [];
  function r() {
    n = n.filter((c) => c().status === "pending");
  }
  function o(c, l, f) {
    const u = gt(
      t,
      c,
      l,
      (d, p) => {
        r(), f && f(d, p);
      }
    );
    return n.push(u), u;
  }
  function i(c) {
    return n.find((l) => c(l)) || null;
  }
  return {
    query: o,
    find: i,
    setIndex: (c) => {
      t.index = c;
    },
    getIndex: () => t.index,
    cleanup: r
  };
}
function ce() {
}
const Q = /* @__PURE__ */ Object.create(null);
function mt(e) {
  if (!Q[e]) {
    const t = Z(e);
    if (!t)
      return;
    const n = Ce(t), r = {
      config: t,
      redundancy: n
    };
    Q[e] = r;
  }
  return Q[e];
}
function yt(e, t, n) {
  let r, o;
  if (typeof e == "string") {
    const i = H(e);
    if (!i)
      return n(void 0, 424), ce;
    o = i.send;
    const s = mt(e);
    s && (r = s.redundancy);
  } else {
    const i = X(e);
    if (i) {
      r = Ce(i);
      const s = e.resources ? e.resources[0] : "", c = H(s);
      c && (o = c.send);
    }
  }
  return !r || !o ? (n(void 0, 424), ce) : r.query(t, o, n)().abort;
}
const le = "iconify2", L = "iconify", ke = L + "-count", fe = L + "-version", Te = 36e5, bt = 168, wt = 50;
function U(e, t) {
  try {
    return e.getItem(t);
  } catch {
  }
}
function ee(e, t, n) {
  try {
    return e.setItem(t, n), !0;
  } catch {
  }
}
function ue(e, t) {
  try {
    e.removeItem(t);
  } catch {
  }
}
function G(e, t) {
  return ee(e, ke, t.toString());
}
function K(e) {
  return parseInt(U(e, ke)) || 0;
}
const v = {
  local: !0,
  session: !0
}, je = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let te = !1;
function xt(e) {
  te = e;
}
let A = typeof window > "u" ? {} : window;
function Pe(e) {
  const t = e + "Storage";
  try {
    if (A && A[t] && typeof A[t].length == "number")
      return A[t];
  } catch {
  }
  v[e] = !1;
}
function Ee(e, t) {
  const n = Pe(e);
  if (!n)
    return;
  const r = U(n, fe);
  if (r !== le) {
    if (r) {
      const c = K(n);
      for (let l = 0; l < c; l++)
        ue(n, L + l.toString());
    }
    ee(n, fe, le), G(n, 0);
    return;
  }
  const o = Math.floor(Date.now() / Te) - bt, i = (c) => {
    const l = L + c.toString(), f = U(n, l);
    if (typeof f == "string") {
      try {
        const u = JSON.parse(f);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > o && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        t(u, c))
          return !0;
      } catch {
      }
      ue(n, l);
    }
  };
  let s = K(n);
  for (let c = s - 1; c >= 0; c--)
    i(c) || (c === s - 1 ? (s--, G(n, s)) : je[e].add(c));
}
function Oe() {
  if (!te) {
    xt(!0);
    for (const e in v)
      Ee(e, (t) => {
        const n = t.data, r = t.provider, o = n.prefix, i = C(
          r,
          o
        );
        if (!W(i, n).length)
          return !1;
        const s = n.lastModified || -1;
        return i.lastModifiedCached = i.lastModifiedCached ? Math.min(i.lastModifiedCached, s) : s, !0;
      });
  }
}
function It(e, t) {
  const n = e.lastModifiedCached;
  if (
    // Matches or newer
    n && n >= t
  )
    return n === t;
  if (e.lastModifiedCached = t, n)
    for (const r in v)
      Ee(r, (o) => {
        const i = o.data;
        return o.provider !== e.provider || i.prefix !== e.prefix || i.lastModified === t;
      });
  return !0;
}
function St(e, t) {
  te || Oe();
  function n(r) {
    let o;
    if (!v[r] || !(o = Pe(r)))
      return;
    const i = je[r];
    let s;
    if (i.size)
      i.delete(s = Array.from(i).shift());
    else if (s = K(o), s >= wt || !G(o, s + 1))
      return;
    const c = {
      cached: Math.floor(Date.now() / Te),
      provider: e.provider,
      data: t
    };
    return ee(
      o,
      L + s.toString(),
      JSON.stringify(c)
    );
  }
  t.lastModified && !It(e, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), n("local") || n("session"));
}
function ae() {
}
function vt(e) {
  e.iconsLoaderFlag || (e.iconsLoaderFlag = !0, setTimeout(() => {
    e.iconsLoaderFlag = !1, ut(e);
  }));
}
function Ct(e, t) {
  e.iconsToLoad ? e.iconsToLoad = e.iconsToLoad.concat(t).sort() : e.iconsToLoad = t, e.iconsQueueFlag || (e.iconsQueueFlag = !0, setTimeout(() => {
    e.iconsQueueFlag = !1;
    const { provider: n, prefix: r } = e, o = e.iconsToLoad;
    delete e.iconsToLoad;
    let i;
    if (!o || !(i = H(n)))
      return;
    i.prepare(n, r, o).forEach((c) => {
      yt(n, c, (l) => {
        if (typeof l != "object")
          c.icons.forEach((f) => {
            e.missing.add(f);
          });
        else
          try {
            const f = W(
              e,
              l
            );
            if (!f.length)
              return;
            const u = e.pendingIcons;
            u && f.forEach((d) => {
              u.delete(d);
            }), St(e, l);
          } catch (f) {
            console.error(f);
          }
        vt(e);
      });
    });
  }));
}
const Le = (e, t) => {
  const n = ht(e, !0, xe()), r = ft(n);
  if (!r.pending.length) {
    let l = !0;
    return t && setTimeout(() => {
      l && t(
        r.loaded,
        r.missing,
        r.pending,
        ae
      );
    }), () => {
      l = !1;
    };
  }
  const o = /* @__PURE__ */ Object.create(null), i = [];
  let s, c;
  return r.pending.forEach((l) => {
    const { provider: f, prefix: u } = l;
    if (u === c && f === s)
      return;
    s = f, c = u, i.push(C(f, u));
    const d = o[f] || (o[f] = /* @__PURE__ */ Object.create(null));
    d[u] || (d[u] = []);
  }), r.pending.forEach((l) => {
    const { provider: f, prefix: u, name: d } = l, p = C(f, u), m = p.pendingIcons || (p.pendingIcons = /* @__PURE__ */ new Set());
    m.has(d) || (m.add(d), o[f][u].push(d));
  }), i.forEach((l) => {
    const { provider: f, prefix: u } = l;
    o[f][u].length && Ct(l, o[f][u]);
  }), t ? dt(t, r, i) : ae;
}, Bt = (e) => new Promise((t, n) => {
  const r = typeof e == "string" ? M(e, !0) : e;
  if (!r) {
    n(e);
    return;
  }
  Le([r || e], (o) => {
    if (o.length && r) {
      const i = B(r);
      if (i) {
        t({
          ...T,
          ...i
        });
        return;
      }
    }
    n(e);
  });
});
function Me(e, t) {
  switch (e) {
    case "local":
    case "session":
      v[e] = t;
      break;
    case "all":
      for (const n in v)
        v[n] = t;
      break;
  }
}
function kt(e, t) {
  const n = {
    ...e
  };
  for (const r in t) {
    const o = t[r], i = typeof o;
    r in Ie ? (o === null || o && (i === "string" || i === "number")) && (n[r] = o) : i === typeof n[r] && (n[r] = r === "rotate" ? o % 4 : o);
  }
  return n;
}
const Tt = /[\s,]+/;
function jt(e, t) {
  t.split(Tt).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        e.hFlip = !0;
        break;
      case "vertical":
        e.vFlip = !0;
        break;
    }
  });
}
function Pt(e, t = 0) {
  const n = e.replace(/^-?[0-9.]*/, "");
  function r(o) {
    for (; o < 0; )
      o += 4;
    return o % 4;
  }
  if (n === "") {
    const o = parseInt(e);
    return isNaN(o) ? 0 : r(o);
  } else if (n !== e) {
    let o = 0;
    switch (n) {
      case "%":
        o = 25;
        break;
      case "deg":
        o = 90;
    }
    if (o) {
      let i = parseFloat(e.slice(0, e.length - n.length));
      return isNaN(i) ? 0 : (i = i / o, i % 1 === 0 ? r(i) : 0);
    }
  }
  return t;
}
function Et(e, t) {
  let n = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const r in t)
    n += " " + r + '="' + t[r] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e + "</svg>";
}
function Ot(e) {
  return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Lt(e) {
  return "data:image/svg+xml," + Ot(e);
}
function Mt(e) {
  return 'url("' + Lt(e) + '")';
}
const de = {
  ...Se,
  inline: !1
}, Ft = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, At = {
  display: "inline-block"
}, J = {
  backgroundColor: "currentColor"
}, Fe = {
  backgroundColor: "transparent"
}, he = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, pe = {
  webkitMask: J,
  mask: J,
  background: Fe
};
for (const e in pe) {
  const t = pe[e];
  for (const n in he)
    t[e + n] = he[n];
}
const N = {};
["horizontal", "vertical"].forEach((e) => {
  const t = e.slice(0, 1) + "Flip";
  N[e + "-flip"] = t, N[e.slice(0, 1) + "-flip"] = t, N[e + "Flip"] = t;
});
function ge(e) {
  return e + (e.match(/^[-0-9.]+$/) ? "px" : "");
}
const me = (e, t) => {
  const n = kt(de, t), r = { ...Ft }, o = t.mode || "svg", i = {}, s = t.style, c = typeof s == "object" && !(s instanceof Array) ? s : {};
  for (let g in t) {
    const a = t[g];
    if (a !== void 0)
      switch (g) {
        // Properties to ignore
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        // Boolean attributes
        case "inline":
        case "hFlip":
        case "vFlip":
          n[g] = a === !0 || a === "true" || a === 1;
          break;
        // Flip as string: 'horizontal,vertical'
        case "flip":
          typeof a == "string" && jt(n, a);
          break;
        // Color: override style
        case "color":
          i.color = a;
          break;
        // Rotation as string
        case "rotate":
          typeof a == "string" ? n[g] = Pt(a) : typeof a == "number" && (n[g] = a);
          break;
        // Remove aria-hidden
        case "ariaHidden":
        case "aria-hidden":
          a !== !0 && a !== "true" && delete r["aria-hidden"];
          break;
        default: {
          const k = N[g];
          k ? (a === !0 || a === "true" || a === 1) && (n[k] = !0) : de[g] === void 0 && (r[g] = a);
        }
      }
  }
  const l = Je(e, n), f = l.attributes;
  if (n.inline && (i.verticalAlign = "-0.125em"), o === "svg") {
    r.style = {
      ...i,
      ...c
    }, Object.assign(r, f);
    let g = 0, a = t.id;
    return typeof a == "string" && (a = a.replace(/-/g, "_")), r.innerHTML = Ze(l.body, a ? () => a + "ID" + g++ : "iconifyVue"), ne("svg", r);
  }
  const { body: u, width: d, height: p } = e, m = o === "mask" || (o === "bg" ? !1 : u.indexOf("currentColor") !== -1), x = Et(u, {
    ...f,
    width: d + "",
    height: p + ""
  });
  return r.style = {
    ...i,
    "--svg": Mt(x),
    width: ge(f.width),
    height: ge(f.height),
    ...At,
    ...m ? J : Fe,
    ...c
  }, ne("span", r);
};
function zt(e) {
  Me(e, !0);
}
function Vt(e) {
  Me(e, !1);
}
xe(!0);
et("", lt);
if (typeof document < "u" && typeof window < "u") {
  Oe();
  const e = window;
  if (e.IconifyPreload !== void 0) {
    const t = e.IconifyPreload, n = "Invalid IconifyPreload syntax.";
    typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((r) => {
      try {
        // Check if item is an object and not null/array
        (typeof r != "object" || r === null || r instanceof Array || // Check for 'icons' and 'prefix'
        typeof r.icons != "object" || typeof r.prefix != "string" || // Add icon set
        !Qe(r)) && console.error(n);
      } catch {
        console.error(n);
      }
    });
  }
  if (e.IconifyProviders !== void 0) {
    const t = e.IconifyProviders;
    if (typeof t == "object" && t !== null)
      for (let n in t) {
        const r = "IconifyProviders[" + n + "] is invalid.";
        try {
          const o = t[n];
          if (typeof o != "object" || !o || o.resources === void 0)
            continue;
          tt(n, o) || console.error(r);
        } catch {
          console.error(r);
        }
      }
  }
}
const _t = {
  ...T,
  body: ""
}, Qt = Ae({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Set initial data
  data() {
    return {
      // Current icon name
      _name: "",
      // Loading
      _loadingIcon: null,
      // Mounted status
      iconMounted: !1,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this.iconMounted = !0;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(e, t) {
      if (typeof e == "object" && e !== null && typeof e.body == "string")
        return this._name = "", this.abortLoading(), {
          data: e
        };
      let n;
      if (typeof e != "string" || (n = M(e, !1, !0)) === null)
        return this.abortLoading(), null;
      const r = B(n);
      if (!r)
        return (!this._loadingIcon || this._loadingIcon.name !== e) && (this.abortLoading(), this._name = "", r !== null && (this._loadingIcon = {
          name: e,
          abort: Le([n], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== e && (this._name = e, t && t(e));
      const o = ["iconify"];
      return n.prefix !== "" && o.push("iconify--" + n.prefix), n.provider !== "" && o.push("iconify--" + n.provider), { data: r, classes: o };
    }
  },
  // Render icon
  render() {
    this.counter;
    const e = this.$attrs, t = this.iconMounted || e.ssr ? this.getIcon(e.icon, e.onLoad) : null;
    if (!t)
      return me(_t, e);
    let n = e;
    return t.classes && (n = {
      ...e,
      class: (typeof e.class == "string" ? e.class + " " : "") + t.classes.join(" ")
    }), me({
      ...T,
      ...t.data
    }, n);
  }
});
export {
  Qt as Icon,
  tt as addAPIProvider,
  Qe as addCollection,
  Ve as addIcon,
  Je as buildIcon,
  ie as calculateSize,
  Vt as disableCache,
  zt as enableCache,
  Rt as getIcon,
  Nt as iconExists,
  Nt as iconLoaded,
  Bt as loadIcon,
  Le as loadIcons,
  Ze as replaceIDs
};
