import { defineComponent as P, h as I } from "vue";
const D = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), A = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), y = Object.freeze({
  ...D,
  ...A
});
Object.freeze({
  ...y,
  body: "",
  hidden: !1
});
({
  ...D
});
const M = Object.freeze({
  width: null,
  height: null
}), E = Object.freeze({
  // Dimensions
  ...M,
  // Transformations
  ...A
});
function z(t, o) {
  const n = {
    ...t
  };
  for (const i in o) {
    const e = o[i], r = typeof e;
    i in M ? (e === null || e && (r === "string" || r === "number")) && (n[i] = e) : r === typeof n[i] && (n[i] = i === "rotate" ? e % 4 : e);
  }
  return n;
}
const N = /[\s,]+/;
function H(t, o) {
  o.split(N).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        t.hFlip = !0;
        break;
      case "vertical":
        t.vFlip = !0;
        break;
    }
  });
}
function L(t, o = 0) {
  const n = t.replace(/^-?[0-9.]*/, "");
  function i(e) {
    for (; e < 0; )
      e += 4;
    return e % 4;
  }
  if (n === "") {
    const e = parseInt(t);
    return isNaN(e) ? 0 : i(e);
  } else if (n !== t) {
    let e = 0;
    switch (n) {
      case "%":
        e = 25;
        break;
      case "deg":
        e = 90;
    }
    if (e) {
      let r = parseFloat(t.slice(0, t.length - n.length));
      return isNaN(r) ? 0 : (r = r / e, r % 1 === 0 ? i(r) : 0);
    }
  }
  return o;
}
const V = /(-?[0-9.]*[0-9]+[0-9.]*)/g, R = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function F(t, o, n) {
  if (o === 1)
    return t;
  if (n = n || 100, typeof t == "number")
    return Math.ceil(t * o * n) / n;
  if (typeof t != "string")
    return t;
  const i = t.split(V);
  if (i === null || !i.length)
    return t;
  const e = [];
  let r = i.shift(), l = R.test(r);
  for (; ; ) {
    if (l) {
      const a = parseFloat(r);
      isNaN(a) ? e.push(r) : e.push(Math.ceil(a * o * n) / n);
    } else
      e.push(r);
    if (r = i.shift(), r === void 0)
      return e.join("");
    l = !l;
  }
}
function G(t, o = "defs") {
  let n = "";
  const i = t.indexOf("<" + o);
  for (; i >= 0; ) {
    const e = t.indexOf(">", i), r = t.indexOf("</" + o);
    if (e === -1 || r === -1)
      break;
    const l = t.indexOf(">", r);
    if (l === -1)
      break;
    n += t.slice(e + 1, r).trim(), t = t.slice(0, i).trim() + t.slice(l + 1);
  }
  return {
    defs: n,
    content: t
  };
}
function U(t, o) {
  return t ? "<defs>" + t + "</defs>" + o : o;
}
function B(t, o, n) {
  const i = G(t);
  return U(i.defs, o + i.content + n);
}
const W = (t) => t === "unset" || t === "undefined" || t === "none";
function _(t, o) {
  const n = {
    ...y,
    ...t
  }, i = {
    ...E,
    ...o
  }, e = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let r = n.body;
  [n, i].forEach((c) => {
    const s = [], k = c.hFlip, v = c.vFlip;
    let h = c.rotate;
    k ? v ? h += 2 : (s.push(
      "translate(" + (e.width + e.left).toString() + " " + (0 - e.top).toString() + ")"
    ), s.push("scale(-1 1)"), e.top = e.left = 0) : v && (s.push(
      "translate(" + (0 - e.left).toString() + " " + (e.height + e.top).toString() + ")"
    ), s.push("scale(1 -1)"), e.top = e.left = 0);
    let u;
    switch (h < 0 && (h -= Math.floor(h / 4) * 4), h = h % 4, h) {
      case 1:
        u = e.height / 2 + e.top, s.unshift(
          "rotate(90 " + u.toString() + " " + u.toString() + ")"
        );
        break;
      case 2:
        s.unshift(
          "rotate(180 " + (e.width / 2 + e.left).toString() + " " + (e.height / 2 + e.top).toString() + ")"
        );
        break;
      case 3:
        u = e.width / 2 + e.left, s.unshift(
          "rotate(-90 " + u.toString() + " " + u.toString() + ")"
        );
        break;
    }
    h % 2 === 1 && (e.left !== e.top && (u = e.left, e.left = e.top, e.top = u), e.width !== e.height && (u = e.width, e.width = e.height, e.height = u)), s.length && (r = B(
      r,
      '<g transform="' + s.join(" ") + '">',
      "</g>"
    ));
  });
  const l = i.width, a = i.height, g = e.width, f = e.height;
  let d, p;
  l === null ? (p = a === null ? "1em" : a === "auto" ? f : a, d = F(p, g / f)) : (d = l === "auto" ? g : l, p = a === null ? F(d, f / g) : a === "auto" ? f : a);
  const m = {}, w = (c, s) => {
    W(s) || (m[c] = s.toString());
  };
  w("width", d), w("height", p);
  const b = [e.left, e.top, g, f];
  return m.viewBox = b.join(" "), {
    attributes: m,
    viewBox: b,
    body: r
  };
}
const K = /\sid="(\S+)"/g, q = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let J = 0;
function Q(t, o = q) {
  const n = [];
  let i;
  for (; i = K.exec(t); )
    n.push(i[1]);
  if (!n.length)
    return t;
  const e = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((r) => {
    const l = typeof o == "function" ? o(r) : o + (J++).toString(), a = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"),
      "$1" + l + e + "$3"
    );
  }), t = t.replace(new RegExp(e, "g"), ""), t;
}
function X(t, o) {
  let n = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const i in o)
    n += " " + i + '="' + o[i] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + t + "</svg>";
}
function Y(t) {
  return t.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Z(t) {
  return "data:image/svg+xml," + Y(t);
}
function tt(t) {
  return 'url("' + Z(t) + '")';
}
const j = {
  ...E,
  inline: !1
}, et = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, nt = {
  display: "inline-block"
}, S = {
  backgroundColor: "currentColor"
}, $ = {
  backgroundColor: "transparent"
}, C = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, O = {
  webkitMask: S,
  mask: S,
  background: $
};
for (const t in O) {
  const o = O[t];
  for (const n in C)
    o[t + n] = C[n];
}
const x = {};
["horizontal", "vertical"].forEach((t) => {
  const o = t.slice(0, 1) + "Flip";
  x[t + "-flip"] = o, x[t.slice(0, 1) + "-flip"] = o, x[t + "Flip"] = o;
});
function T(t) {
  return t + (t.match(/^[-0-9.]+$/) ? "px" : "");
}
const ot = (t, o) => {
  const n = z(j, o), i = { ...et }, e = o.mode || "svg", r = {}, l = o.style, a = typeof l == "object" && !(l instanceof Array) ? l : {};
  for (let c in o) {
    const s = o[c];
    if (s !== void 0)
      switch (c) {
        // Properties to ignore
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        // Boolean attributes
        case "inline":
        case "hFlip":
        case "vFlip":
          n[c] = s === !0 || s === "true" || s === 1;
          break;
        // Flip as string: 'horizontal,vertical'
        case "flip":
          typeof s == "string" && H(n, s);
          break;
        // Color: override style
        case "color":
          r.color = s;
          break;
        // Rotation as string
        case "rotate":
          typeof s == "string" ? n[c] = L(s) : typeof s == "number" && (n[c] = s);
          break;
        // Remove aria-hidden
        case "ariaHidden":
        case "aria-hidden":
          s !== !0 && s !== "true" && delete i["aria-hidden"];
          break;
        default: {
          const k = x[c];
          k ? (s === !0 || s === "true" || s === 1) && (n[k] = !0) : j[c] === void 0 && (i[c] = s);
        }
      }
  }
  const g = _(t, n), f = g.attributes;
  if (n.inline && (r.verticalAlign = "-0.125em"), e === "svg") {
    i.style = {
      ...r,
      ...a
    }, Object.assign(i, f);
    let c = 0, s = o.id;
    return typeof s == "string" && (s = s.replace(/-/g, "_")), i.innerHTML = Q(g.body, s ? () => s + "ID" + c++ : "iconifyVue"), I("svg", i);
  }
  const { body: d, width: p, height: m } = t, w = e === "mask" || (e === "bg" ? !1 : d.indexOf("currentColor") !== -1), b = X(d, {
    ...f,
    width: p + "",
    height: m + ""
  });
  return i.style = {
    ...r,
    "--svg": tt(b),
    width: T(f.width),
    height: T(f.height),
    ...nt,
    ...w ? S : $,
    ...a
  }, I("span", i);
}, it = /* @__PURE__ */ Object.create(null), rt = P({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Render icon
  render() {
    const t = this.$attrs, o = t.icon, n = typeof o == "string" ? it[o] : typeof o == "object" ? o : null;
    return n === null || typeof n != "object" || typeof n.body != "string" ? this.$slots.default ? this.$slots.default() : null : ot({
      ...y,
      ...n
    }, t);
  }
});
export {
  rt as Icon
};
